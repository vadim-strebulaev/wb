//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export module contracts {
export const REDICY_API_BASE_URL = new InjectionToken<string>('REDICY_API_BASE_URL');

@Injectable()
export class DashboardClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(REDICY_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getLatestSalesInfo(): Observable<LatestSales | null> {
        let url_ = this.baseUrl + "/v1/Dashboard/GetLatestSalesInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestSalesInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestSalesInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LatestSales | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LatestSales | null>;
        }));
    }

    protected processGetLatestSalesInfo(response: HttpResponseBase): Observable<LatestSales | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LatestSales.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ImageToolClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(REDICY_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    createVideoBatch(): Observable<string> {
        let url_ = this.baseUrl + "/v1/ImageTool/CreateVideoBatch";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateVideoBatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateVideoBatch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreateVideoBatch(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    finishBatch(batchID: string, frameRate: number): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/v1/ImageTool/FinishBatch?";
        if (batchID === undefined || batchID === null)
            throw new Error("The parameter 'batchID' must be defined and cannot be null.");
        else
            url_ += "batchID=" + encodeURIComponent("" + batchID) + "&";
        if (frameRate === undefined || frameRate === null)
            throw new Error("The parameter 'frameRate' must be defined and cannot be null.");
        else
            url_ += "frameRate=" + encodeURIComponent("" + frameRate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFinishBatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFinishBatch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processFinishBatch(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    uploadBatchImage(batchID: string, files: FileParameter[] | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/v1/ImageTool/UploadBatchImage?";
        if (batchID === undefined || batchID === null)
            throw new Error("The parameter 'batchID' must be defined and cannot be null.");
        else
            url_ += "batchID=" + encodeURIComponent("" + batchID) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files !== null && files !== undefined)
            files.forEach(item_ => content_.append("files", item_.data, item_.fileName ? item_.fileName : "files") );

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadBatchImage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadBatchImage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUploadBatchImage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OzonClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(REDICY_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    importProducts(): Observable<void> {
        let url_ = this.baseUrl + "/v1/Ozon/ImportProducts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportProducts(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    importTransactions(dateFrom: Date | null, dateTo: Date | null): Observable<void> {
        let url_ = this.baseUrl + "/v1/Ozon/ImportTransactions?";
        if (dateFrom === undefined)
            throw new Error("The parameter 'dateFrom' must be defined.");
        else if(dateFrom !== null)
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === undefined)
            throw new Error("The parameter 'dateTo' must be defined.");
        else if(dateTo !== null)
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportTransactions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportTransactions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    importWarehouses(): Observable<void> {
        let url_ = this.baseUrl + "/v1/Ozon/ImportWarehouses";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportWarehouses(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportWarehouses(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportWarehouses(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    importProductStocks(): Observable<void> {
        let url_ = this.baseUrl + "/v1/Ozon/ImportProductStocks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportProductStocks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportProductStocks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportProductStocks(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    importOzonPostings(dateFrom: Date | null, dateTo: Date | null): Observable<void> {
        let url_ = this.baseUrl + "/v1/Ozon/ImportOzonPostings?";
        if (dateFrom === undefined)
            throw new Error("The parameter 'dateFrom' must be defined.");
        else if(dateFrom !== null)
            url_ += "dateFrom=" + encodeURIComponent(dateFrom ? "" + dateFrom.toISOString() : "") + "&";
        if (dateTo === undefined)
            throw new Error("The parameter 'dateTo' must be defined.");
        else if(dateTo !== null)
            url_ += "dateTo=" + encodeURIComponent(dateTo ? "" + dateTo.toISOString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportOzonPostings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportOzonPostings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportOzonPostings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    importOzonSupplyOrders(): Observable<void> {
        let url_ = this.baseUrl + "/v1/Ozon/ImportOzonSupplyOrders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportOzonSupplyOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportOzonSupplyOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processImportOzonSupplyOrders(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    findOzonOrders(model: FindPostingsModel | null | undefined): Observable<OzonSalesOrder[] | null> {
        let url_ = this.baseUrl + "/v1/Ozon/FindOzonOrders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindOzonOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindOzonOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OzonSalesOrder[] | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OzonSalesOrder[] | null>;
        }));
    }

    protected processFindOzonOrders(response: HttpResponseBase): Observable<OzonSalesOrder[] | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OzonSalesOrder.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    findOzonSupplyOrders(model: FindOzonSupplyOrdersModel | null | undefined): Observable<PagedResponseOfOzonSupplyOrders | null> {
        let url_ = this.baseUrl + "/v1/Ozon/FindOzonSupplyOrders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindOzonSupplyOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindOzonSupplyOrders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResponseOfOzonSupplyOrders | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResponseOfOzonSupplyOrders | null>;
        }));
    }

    protected processFindOzonSupplyOrders(response: HttpResponseBase): Observable<PagedResponseOfOzonSupplyOrders | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResponseOfOzonSupplyOrders.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    findOzonProducts(model: FindOzonProductsModel | null | undefined): Observable<PagedResponseOfOzonProducts | null> {
        let url_ = this.baseUrl + "/v1/Ozon/FindOzonProducts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindOzonProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindOzonProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResponseOfOzonProducts | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResponseOfOzonProducts | null>;
        }));
    }

    protected processFindOzonProducts(response: HttpResponseBase): Observable<PagedResponseOfOzonProducts | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResponseOfOzonProducts.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    findOzonOperations(model: FindOzonOperationsModel | null | undefined): Observable<PagedResponseOfOzonOperations | null> {
        let url_ = this.baseUrl + "/v1/Ozon/FindOzonOperations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindOzonOperations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindOzonOperations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResponseOfOzonOperations | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResponseOfOzonOperations | null>;
        }));
    }

    protected processFindOzonOperations(response: HttpResponseBase): Observable<PagedResponseOfOzonOperations | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResponseOfOzonOperations.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PackageTypeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(REDICY_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getPackageTypesWithLatestPrices(): Observable<PackageTypeWithPrice[] | null> {
        let url_ = this.baseUrl + "/v1/PackageType/GetPackageTypesWithLatestPrices";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPackageTypesWithLatestPrices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPackageTypesWithLatestPrices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PackageTypeWithPrice[] | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PackageTypeWithPrice[] | null>;
        }));
    }

    protected processGetPackageTypesWithLatestPrices(response: HttpResponseBase): Observable<PackageTypeWithPrice[] | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PackageTypeWithPrice.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProductClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(REDICY_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    findProducts(model: FindProductsModel | null | undefined): Observable<PagedResponseOfProduct | null> {
        let url_ = this.baseUrl + "/v1/Product/FindProducts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindProducts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResponseOfProduct | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResponseOfProduct | null>;
        }));
    }

    protected processFindProducts(response: HttpResponseBase): Observable<PagedResponseOfProduct | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResponseOfProduct.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    findProductPackages(model: FindProductPackagesModel | null | undefined): Observable<PagedResponseOfProductPackage | null> {
        let url_ = this.baseUrl + "/v1/Product/FindProductPackages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindProductPackages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindProductPackages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResponseOfProductPackage | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResponseOfProductPackage | null>;
        }));
    }

    protected processFindProductPackages(response: HttpResponseBase): Observable<PagedResponseOfProductPackage | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResponseOfProductPackage.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PurchaseBatchClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(REDICY_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    updatePurchaseBatch(model: PurchaseBatch | null | undefined): Observable<PurchaseBatch | null> {
        let url_ = this.baseUrl + "/v1/PurchaseBatch/UpdatePurchaseBatch";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePurchaseBatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePurchaseBatch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseBatch | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseBatch | null>;
        }));
    }

    protected processUpdatePurchaseBatch(response: HttpResponseBase): Observable<PurchaseBatch | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PurchaseBatch.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getPurchaseBatch(model: number): Observable<PurchaseBatch | null> {
        let url_ = this.baseUrl + "/v1/PurchaseBatch/GetPurchaseBatch?";
        if (model === undefined || model === null)
            throw new Error("The parameter 'model' must be defined and cannot be null.");
        else
            url_ += "model=" + encodeURIComponent("" + model) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPurchaseBatch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPurchaseBatch(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PurchaseBatch | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PurchaseBatch | null>;
        }));
    }

    protected processGetPurchaseBatch(response: HttpResponseBase): Observable<PurchaseBatch | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PurchaseBatch.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    findPurchaseBatches(model: FindPurchaseBatchesModel | null | undefined): Observable<PagedResponseOfPurchaseBatches | null> {
        let url_ = this.baseUrl + "/v1/PurchaseBatch/FindPurchaseBatches";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindPurchaseBatches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindPurchaseBatches(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResponseOfPurchaseBatches | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResponseOfPurchaseBatches | null>;
        }));
    }

    protected processFindPurchaseBatches(response: HttpResponseBase): Observable<PagedResponseOfPurchaseBatches | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PagedResponseOfPurchaseBatches.fromJS(resultData200) : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getSalesPlansSummaries(model: number[] | null | undefined): Observable<SalesPlanSummary[] | null> {
        let url_ = this.baseUrl + "/v1/PurchaseBatch/GetSalesPlansSummaries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesPlansSummaries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesPlansSummaries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalesPlanSummary[] | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalesPlanSummary[] | null>;
        }));
    }

    protected processGetSalesPlansSummaries(response: HttpResponseBase): Observable<SalesPlanSummary[] | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SalesPlanSummary.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    calcSalesPlans(): Observable<void> {
        let url_ = this.baseUrl + "/v1/PurchaseBatch/CalcSalesPlansAsync";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCalcSalesPlans(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCalcSalesPlans(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCalcSalesPlans(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SalesChannelClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(REDICY_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getSalesChannels(): Observable<SalesChannel[] | null> {
        let url_ = this.baseUrl + "/v1/SalesChannel/GetSalesChannels";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesChannels(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesChannels(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SalesChannel[] | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SalesChannel[] | null>;
        }));
    }

    protected processGetSalesChannels(response: HttpResponseBase): Observable<SalesChannel[] | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SalesChannel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TokenClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(REDICY_API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    generateToken(model: LoginModel | null | undefined): Observable<JwtToken> {
        let url_ = this.baseUrl + "/Token/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JwtToken>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JwtToken>;
        }));
    }

    protected processGenerateToken(response: HttpResponseBase): Observable<JwtToken> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JwtToken.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    refreshToken(refreshToken: string | null | undefined): Observable<JwtToken> {
        let url_ = this.baseUrl + "/Token/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(refreshToken);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<JwtToken>;
                }
            } else
                return _observableThrow(response_) as any as Observable<JwtToken>;
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<JwtToken> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = JwtToken.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 503) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("A server side error occurred.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class LatestSales implements ILatestSales {
    lastDayOrderCount!: number;
    lastDayOrderSum?: number | undefined;
    weekSales?: WeekSales | undefined;
    lastSales?: OzonSalesOrder[] | undefined;

    constructor(data?: ILatestSales) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lastDayOrderCount = _data["LastDayOrderCount"];
            this.lastDayOrderSum = _data["LastDayOrderSum"];
            this.weekSales = _data["WeekSales"] ? WeekSales.fromJS(_data["WeekSales"]) : <any>undefined;
            if (Array.isArray(_data["LastSales"])) {
                this.lastSales = [] as any;
                for (let item of _data["LastSales"])
                    this.lastSales!.push(OzonSalesOrder.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LatestSales {
        data = typeof data === 'object' ? data : {};
        let result = new LatestSales();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["LastDayOrderCount"] = this.lastDayOrderCount;
        data["LastDayOrderSum"] = this.lastDayOrderSum;
        data["WeekSales"] = this.weekSales ? this.weekSales.toJSON() : <any>undefined;
        if (Array.isArray(this.lastSales)) {
            data["LastSales"] = [];
            for (let item of this.lastSales)
                data["LastSales"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILatestSales {
    lastDayOrderCount: number;
    lastDayOrderSum?: number | undefined;
    weekSales?: WeekSales | undefined;
    lastSales?: OzonSalesOrder[] | undefined;
}

export class WeekSales implements IWeekSales {
    lastWeekIncome?: number | undefined;
    previousWeekIncome?: number | undefined;

    constructor(data?: IWeekSales) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lastWeekIncome = _data["LastWeekIncome"];
            this.previousWeekIncome = _data["PreviousWeekIncome"];
        }
    }

    static fromJS(data: any): WeekSales {
        data = typeof data === 'object' ? data : {};
        let result = new WeekSales();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["LastWeekIncome"] = this.lastWeekIncome;
        data["PreviousWeekIncome"] = this.previousWeekIncome;
        return data;
    }
}

export interface IWeekSales {
    lastWeekIncome?: number | undefined;
    previousWeekIncome?: number | undefined;
}

export class OzonSalesOrder implements IOzonSalesOrder {
    iD!: number;
    ozonOrderID?: number | undefined;
    ozonOrderNumber?: string | undefined;
    date!: Date;
    operations?: OzonOperation[] | undefined;
    orderItems?: OzonSalesOrderItem[] | undefined;

    constructor(data?: IOzonSalesOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iD = _data["ID"];
            this.ozonOrderID = _data["OzonOrderID"];
            this.ozonOrderNumber = _data["OzonOrderNumber"];
            this.date = _data["Date"] ? new Date(_data["Date"].toString()) : <any>undefined;
            if (Array.isArray(_data["Operations"])) {
                this.operations = [] as any;
                for (let item of _data["Operations"])
                    this.operations!.push(OzonOperation.fromJS(item));
            }
            if (Array.isArray(_data["OrderItems"])) {
                this.orderItems = [] as any;
                for (let item of _data["OrderItems"])
                    this.orderItems!.push(OzonSalesOrderItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OzonSalesOrder {
        data = typeof data === 'object' ? data : {};
        let result = new OzonSalesOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD;
        data["OzonOrderID"] = this.ozonOrderID;
        data["OzonOrderNumber"] = this.ozonOrderNumber;
        data["Date"] = this.date ? this.date.toISOString() : <any>undefined;
        if (Array.isArray(this.operations)) {
            data["Operations"] = [];
            for (let item of this.operations)
                data["Operations"].push(item.toJSON());
        }
        if (Array.isArray(this.orderItems)) {
            data["OrderItems"] = [];
            for (let item of this.orderItems)
                data["OrderItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOzonSalesOrder {
    iD: number;
    ozonOrderID?: number | undefined;
    ozonOrderNumber?: string | undefined;
    date: Date;
    operations?: OzonOperation[] | undefined;
    orderItems?: OzonSalesOrderItem[] | undefined;
}

export class OzonOperation implements IOzonOperation {
    iD!: number;
    date!: Date;
    accrualsForSale!: number;
    amount!: number;
    saleCommission!: number;
    operationType!: OperationType;
    accrualType!: TransactionType;
    deliveryCharge!: number;
    returnDeliveryCharge!: number;
    postingNumber?: string | undefined;
    services?: OzonOperationService[] | undefined;

    constructor(data?: IOzonOperation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iD = _data["ID"];
            this.date = _data["Date"] ? new Date(_data["Date"].toString()) : <any>undefined;
            this.accrualsForSale = _data["AccrualsForSale"];
            this.amount = _data["Amount"];
            this.saleCommission = _data["SaleCommission"];
            this.operationType = _data["OperationType"];
            this.accrualType = _data["AccrualType"];
            this.deliveryCharge = _data["DeliveryCharge"];
            this.returnDeliveryCharge = _data["ReturnDeliveryCharge"];
            this.postingNumber = _data["PostingNumber"];
            if (Array.isArray(_data["Services"])) {
                this.services = [] as any;
                for (let item of _data["Services"])
                    this.services!.push(OzonOperationService.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OzonOperation {
        data = typeof data === 'object' ? data : {};
        let result = new OzonOperation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD;
        data["Date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["AccrualsForSale"] = this.accrualsForSale;
        data["Amount"] = this.amount;
        data["SaleCommission"] = this.saleCommission;
        data["OperationType"] = this.operationType;
        data["AccrualType"] = this.accrualType;
        data["DeliveryCharge"] = this.deliveryCharge;
        data["ReturnDeliveryCharge"] = this.returnDeliveryCharge;
        data["PostingNumber"] = this.postingNumber;
        if (Array.isArray(this.services)) {
            data["Services"] = [];
            for (let item of this.services)
                data["Services"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOzonOperation {
    iD: number;
    date: Date;
    accrualsForSale: number;
    amount: number;
    saleCommission: number;
    operationType: OperationType;
    accrualType: TransactionType;
    deliveryCharge: number;
    returnDeliveryCharge: number;
    postingNumber?: string | undefined;
    services?: OzonOperationService[] | undefined;
}

export enum OperationType {
    ClientReturnAgentOperation = 0,
    MarketplaceMarketingActionCostOperation = 1,
    MarketplaceSaleReviewsOperation = 2,
    MarketplaceSellerCompensationOperation = 3,
    OperationAgentDeliveredToCustomer = 4,
    OperationAgentDeliveredToCustomerCanceled = 5,
    OperationAgentStornoDeliveredToCustomer = 6,
    OperationClaim = 7,
    OperationCorrectionSeller = 8,
    OperationDefectiveWriteOff = 9,
    OperationItemReturn = 10,
    OperationLackWriteOff = 11,
    OperationMarketplaceCrossDockServiceWriteOff = 12,
    OperationMarketplaceServiceStorage = 13,
    OperationSetOff = 14,
    MarketplaceSellerReexposureDeliveryReturnOperation = 15,
    OperationReturnGoodsFBSofRMS = 16,
    ReturnAgentOperationRFBS = 17,
    MarketplaceSellerShippingCompensationReturnOperation = 18,
    OperationMarketplaceServicePremiumCashback = 19,
    MarketplaceServicePremiumPromotion = 20,
    MarketplaceRedistributionOfAcquiringOperation = 21,
    MarketplaceReturnStorageServiceAtThePickupPointFbsItem = 22,
    MarketplaceReturnStorageServiceInTheWarehouseFbsItem = 23,
    MarketplaceServiceItemDeliveryKGT = 24,
    MarketplaceServiceItemDirectFlowLogistic = 25,
    MarketplaceServiceItemReturnFlowLogistic = 26,
    MarketplaceServicePremiumCashbackIndividualPoints = 27,
    OperationMarketplaceWithHoldingForUndeliverableGoods = 28,
    OperationMarketplaceSupplyAdditional = 29,
    OperationMarketplaceSupplyExpirationDateProcessing = 30,
}

export enum TransactionType {
    All = 0,
    Orders = 1,
    Returns = 2,
    Services = 3,
    Compensation = 4,
    TransferDelivery = 5,
    Other = 6,
}

export class OzonOperationService implements IOzonOperationService {
    type!: OperationServiceType;
    price!: number;

    constructor(data?: IOzonOperationService) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["Type"];
            this.price = _data["Price"];
        }
    }

    static fromJS(data: any): OzonOperationService {
        data = typeof data === 'object' ? data : {};
        let result = new OzonOperationService();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Type"] = this.type;
        data["Price"] = this.price;
        return data;
    }
}

export interface IOzonOperationService {
    type: OperationServiceType;
    price: number;
}

export enum OperationServiceType {
    MarketplaceNotDeliveredCostItem = 0,
    MarketplaceReturnAfterDeliveryCostItem = 1,
    MarketplaceDeliveryCostItem = 2,
    MarketplaceSaleReviewsItem = 3,
    ItemAdvertisementForSupplierLogistic = 4,
    MarketplaceServiceStorageItem = 5,
    MarketplaceMarketingActionCostItem = 6,
    MarketplaceServiceItemInstallment = 7,
    MarketplaceServiceItemMarkingItems = 8,
    MarketplaceServiceItemFlexiblePaymentSchedule = 9,
    MarketplaceServiceItemReturnFromStock = 10,
    ItemAdvertisementForSupplierLogisticSeller = 11,
    MarketplaceServiceItemDelivToCustomer = 12,
    MarketplaceServiceItemDirectFlowTrans = 13,
    MarketplaceServiceItemDropoffFF = 14,
    MarketplaceServiceItemDropoffPVZ = 15,
    MarketplaceServiceItemDropoffSC = 16,
    MarketplaceServiceItemFulfillment = 17,
    MarketplaceServiceItemPickup = 18,
    MarketplaceServiceItemReturnAfterDelivToCustomer = 19,
    MarketplaceServiceItemReturnFlowTrans = 20,
    MarketplaceServiceItemReturnNotDelivToCustomer = 21,
    MarketplaceServiceItemReturnPartGoodsCustomer = 22,
    MarketplaceRedistributionOfAcquiringOperation = 23,
    MarketplaceReturnStorageServiceAtThePickupPointFbsItem = 24,
    MarketplaceReturnStorageServiceInTheWarehouseFbsItem = 25,
    MarketplaceServiceItemDeliveryKGT = 26,
    MarketplaceServiceItemDirectFlowLogistic = 27,
    MarketplaceServiceItemReturnFlowLogistic = 28,
    MarketplaceServicePremiumCashbackIndividualPoints = 29,
    MarketplaceServicePremiumPromotion = 30,
    OperationMarketplaceWithHoldingForUndeliverableGoods = 31,
}

export class OzonSalesOrderItem implements IOzonSalesOrderItem {
    iD!: number;
    postingNumber?: string | undefined;
    currencyCode!: Currency;
    price!: number;
    quantity!: number;
    product?: OzonProduct | undefined;
    status!: PostingStatus;
    city?: string | undefined;
    region?: string | undefined;
    deliveryType?: string | undefined;
    ozonWarehouse?: OzonWarehouse | undefined;

    constructor(data?: IOzonSalesOrderItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iD = _data["ID"];
            this.postingNumber = _data["PostingNumber"];
            this.currencyCode = _data["CurrencyCode"];
            this.price = _data["Price"];
            this.quantity = _data["Quantity"];
            this.product = _data["Product"] ? OzonProduct.fromJS(_data["Product"]) : <any>undefined;
            this.status = _data["Status"];
            this.city = _data["City"];
            this.region = _data["Region"];
            this.deliveryType = _data["DeliveryType"];
            this.ozonWarehouse = _data["OzonWarehouse"] ? OzonWarehouse.fromJS(_data["OzonWarehouse"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OzonSalesOrderItem {
        data = typeof data === 'object' ? data : {};
        let result = new OzonSalesOrderItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD;
        data["PostingNumber"] = this.postingNumber;
        data["CurrencyCode"] = this.currencyCode;
        data["Price"] = this.price;
        data["Quantity"] = this.quantity;
        data["Product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["Status"] = this.status;
        data["City"] = this.city;
        data["Region"] = this.region;
        data["DeliveryType"] = this.deliveryType;
        data["OzonWarehouse"] = this.ozonWarehouse ? this.ozonWarehouse.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOzonSalesOrderItem {
    iD: number;
    postingNumber?: string | undefined;
    currencyCode: Currency;
    price: number;
    quantity: number;
    product?: OzonProduct | undefined;
    status: PostingStatus;
    city?: string | undefined;
    region?: string | undefined;
    deliveryType?: string | undefined;
    ozonWarehouse?: OzonWarehouse | undefined;
}

export enum Currency {
    RUB = 0,
    BYN = 1,
    KZT = 2,
    EUR = 3,
    USD = 4,
    CNY = 5,
}

export class OzonProduct implements IOzonProduct {
    productPackageID!: number;
    name?: string | undefined;
    categoryID!: number;
    fboSku!: number;
    fbsSku!: number;
    sku!: number;
    barcodes?: string[] | undefined;
    marketingPrice?: number | undefined;
    minPrice?: number | undefined;
    oldPrice?: number | undefined;
    premiumPrice?: number | undefined;
    price!: number;
    recommendedPrice?: number | undefined;
    externalCompetitorMinimalPrice?: number | undefined;
    externalCompetitorMinimalPriceCurrency?: Currency | undefined;
    externalCompetitorPriceIndexValue?: number | undefined;
    ozonCompetitorMinimalPrice?: number | undefined;
    ozonCompetitorMinimalPriceCurrency?: Currency | undefined;
    ozonCompetitorPriceIndexValue?: number | undefined;
    externalMinimalPrice?: number | undefined;
    externalMinimalPriceCurrency?: Currency | undefined;
    externalPriceIndexValue?: number | undefined;
    stocks?: OzonProductStock[] | undefined;

    constructor(data?: IOzonProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.productPackageID = _data["ProductPackageID"];
            this.name = _data["Name"];
            this.categoryID = _data["CategoryID"];
            this.fboSku = _data["FboSku"];
            this.fbsSku = _data["FbsSku"];
            this.sku = _data["Sku"];
            if (Array.isArray(_data["Barcodes"])) {
                this.barcodes = [] as any;
                for (let item of _data["Barcodes"])
                    this.barcodes!.push(item);
            }
            this.marketingPrice = _data["MarketingPrice"];
            this.minPrice = _data["MinPrice"];
            this.oldPrice = _data["OldPrice"];
            this.premiumPrice = _data["PremiumPrice"];
            this.price = _data["Price"];
            this.recommendedPrice = _data["RecommendedPrice"];
            this.externalCompetitorMinimalPrice = _data["ExternalCompetitorMinimalPrice"];
            this.externalCompetitorMinimalPriceCurrency = _data["ExternalCompetitorMinimalPriceCurrency"];
            this.externalCompetitorPriceIndexValue = _data["ExternalCompetitorPriceIndexValue"];
            this.ozonCompetitorMinimalPrice = _data["OzonCompetitorMinimalPrice"];
            this.ozonCompetitorMinimalPriceCurrency = _data["OzonCompetitorMinimalPriceCurrency"];
            this.ozonCompetitorPriceIndexValue = _data["OzonCompetitorPriceIndexValue"];
            this.externalMinimalPrice = _data["ExternalMinimalPrice"];
            this.externalMinimalPriceCurrency = _data["ExternalMinimalPriceCurrency"];
            this.externalPriceIndexValue = _data["ExternalPriceIndexValue"];
            if (Array.isArray(_data["Stocks"])) {
                this.stocks = [] as any;
                for (let item of _data["Stocks"])
                    this.stocks!.push(OzonProductStock.fromJS(item));
            }
        }
    }

    static fromJS(data: any): OzonProduct {
        data = typeof data === 'object' ? data : {};
        let result = new OzonProduct();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ProductPackageID"] = this.productPackageID;
        data["Name"] = this.name;
        data["CategoryID"] = this.categoryID;
        data["FboSku"] = this.fboSku;
        data["FbsSku"] = this.fbsSku;
        data["Sku"] = this.sku;
        if (Array.isArray(this.barcodes)) {
            data["Barcodes"] = [];
            for (let item of this.barcodes)
                data["Barcodes"].push(item);
        }
        data["MarketingPrice"] = this.marketingPrice;
        data["MinPrice"] = this.minPrice;
        data["OldPrice"] = this.oldPrice;
        data["PremiumPrice"] = this.premiumPrice;
        data["Price"] = this.price;
        data["RecommendedPrice"] = this.recommendedPrice;
        data["ExternalCompetitorMinimalPrice"] = this.externalCompetitorMinimalPrice;
        data["ExternalCompetitorMinimalPriceCurrency"] = this.externalCompetitorMinimalPriceCurrency;
        data["ExternalCompetitorPriceIndexValue"] = this.externalCompetitorPriceIndexValue;
        data["OzonCompetitorMinimalPrice"] = this.ozonCompetitorMinimalPrice;
        data["OzonCompetitorMinimalPriceCurrency"] = this.ozonCompetitorMinimalPriceCurrency;
        data["OzonCompetitorPriceIndexValue"] = this.ozonCompetitorPriceIndexValue;
        data["ExternalMinimalPrice"] = this.externalMinimalPrice;
        data["ExternalMinimalPriceCurrency"] = this.externalMinimalPriceCurrency;
        data["ExternalPriceIndexValue"] = this.externalPriceIndexValue;
        if (Array.isArray(this.stocks)) {
            data["Stocks"] = [];
            for (let item of this.stocks)
                data["Stocks"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOzonProduct {
    productPackageID: number;
    name?: string | undefined;
    categoryID: number;
    fboSku: number;
    fbsSku: number;
    sku: number;
    barcodes?: string[] | undefined;
    marketingPrice?: number | undefined;
    minPrice?: number | undefined;
    oldPrice?: number | undefined;
    premiumPrice?: number | undefined;
    price: number;
    recommendedPrice?: number | undefined;
    externalCompetitorMinimalPrice?: number | undefined;
    externalCompetitorMinimalPriceCurrency?: Currency | undefined;
    externalCompetitorPriceIndexValue?: number | undefined;
    ozonCompetitorMinimalPrice?: number | undefined;
    ozonCompetitorMinimalPriceCurrency?: Currency | undefined;
    ozonCompetitorPriceIndexValue?: number | undefined;
    externalMinimalPrice?: number | undefined;
    externalMinimalPriceCurrency?: Currency | undefined;
    externalPriceIndexValue?: number | undefined;
    stocks?: OzonProductStock[] | undefined;
}

export class OzonProductStock implements IOzonProductStock {
    present!: number;
    reserved!: number;
    productID!: number;
    warehouseID!: number;
    warehouse?: OzonWarehouse | undefined;

    constructor(data?: IOzonProductStock) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.present = _data["Present"];
            this.reserved = _data["Reserved"];
            this.productID = _data["ProductID"];
            this.warehouseID = _data["WarehouseID"];
            this.warehouse = _data["Warehouse"] ? OzonWarehouse.fromJS(_data["Warehouse"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OzonProductStock {
        data = typeof data === 'object' ? data : {};
        let result = new OzonProductStock();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Present"] = this.present;
        data["Reserved"] = this.reserved;
        data["ProductID"] = this.productID;
        data["WarehouseID"] = this.warehouseID;
        data["Warehouse"] = this.warehouse ? this.warehouse.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOzonProductStock {
    present: number;
    reserved: number;
    productID: number;
    warehouseID: number;
    warehouse?: OzonWarehouse | undefined;
}

export class OzonWarehouse implements IOzonWarehouse {
    iD!: number;
    name?: string | undefined;
    address?: string | undefined;

    constructor(data?: IOzonWarehouse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iD = _data["ID"];
            this.name = _data["Name"];
            this.address = _data["Address"];
        }
    }

    static fromJS(data: any): OzonWarehouse {
        data = typeof data === 'object' ? data : {};
        let result = new OzonWarehouse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD;
        data["Name"] = this.name;
        data["Address"] = this.address;
        return data;
    }
}

export interface IOzonWarehouse {
    iD: number;
    name?: string | undefined;
    address?: string | undefined;
}

export enum PostingStatus {
    AwaitingPackaging = 0,
    AwaitingDeliver = 1,
    Delivering = 2,
    Delivered = 3,
    Cancelled = 4,
}

export class FindPostingsModel implements IFindPostingsModel {
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
    postingNumbers?: string[] | undefined;

    constructor(data?: IFindPostingsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateFrom = _data["DateFrom"] ? new Date(_data["DateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["DateTo"] ? new Date(_data["DateTo"].toString()) : <any>undefined;
            if (Array.isArray(_data["PostingNumbers"])) {
                this.postingNumbers = [] as any;
                for (let item of _data["PostingNumbers"])
                    this.postingNumbers!.push(item);
            }
        }
    }

    static fromJS(data: any): FindPostingsModel {
        data = typeof data === 'object' ? data : {};
        let result = new FindPostingsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["DateFrom"] = this.dateFrom ? this.dateFrom.toISOString() : <any>undefined;
        data["DateTo"] = this.dateTo ? this.dateTo.toISOString() : <any>undefined;
        if (Array.isArray(this.postingNumbers)) {
            data["PostingNumbers"] = [];
            for (let item of this.postingNumbers)
                data["PostingNumbers"].push(item);
        }
        return data;
    }
}

export interface IFindPostingsModel {
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
    postingNumbers?: string[] | undefined;
}

export class PagedResponseOfOzonSupplyOrders implements IPagedResponseOfOzonSupplyOrders {
    totalCount!: number;
    items?: OzonSupplyOrder[] | undefined;

    constructor(data?: IPagedResponseOfOzonSupplyOrders) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["TotalCount"];
            if (Array.isArray(_data["Items"])) {
                this.items = [] as any;
                for (let item of _data["Items"])
                    this.items!.push(OzonSupplyOrder.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResponseOfOzonSupplyOrders {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfOzonSupplyOrders();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TotalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["Items"] = [];
            for (let item of this.items)
                data["Items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResponseOfOzonSupplyOrders {
    totalCount: number;
    items?: OzonSupplyOrder[] | undefined;
}

export class OzonSupplyOrder implements IOzonSupplyOrder {
    iD!: number;
    ozonOrderNumber!: string;
    totalQuantity!: number;
    totalItemCount!: number;
    ozonWarehouseID?: number | undefined;
    date?: Date | undefined;
    ozonWarehouse?: OzonWarehouse | undefined;

    constructor(data?: IOzonSupplyOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iD = _data["ID"];
            this.ozonOrderNumber = _data["OzonOrderNumber"];
            this.totalQuantity = _data["TotalQuantity"];
            this.totalItemCount = _data["TotalItemCount"];
            this.ozonWarehouseID = _data["OzonWarehouseID"];
            this.date = _data["Date"] ? new Date(_data["Date"].toString()) : <any>undefined;
            this.ozonWarehouse = _data["OzonWarehouse"] ? OzonWarehouse.fromJS(_data["OzonWarehouse"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OzonSupplyOrder {
        data = typeof data === 'object' ? data : {};
        let result = new OzonSupplyOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD;
        data["OzonOrderNumber"] = this.ozonOrderNumber;
        data["TotalQuantity"] = this.totalQuantity;
        data["TotalItemCount"] = this.totalItemCount;
        data["OzonWarehouseID"] = this.ozonWarehouseID;
        data["Date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["OzonWarehouse"] = this.ozonWarehouse ? this.ozonWarehouse.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOzonSupplyOrder {
    iD: number;
    ozonOrderNumber: string;
    totalQuantity: number;
    totalItemCount: number;
    ozonWarehouseID?: number | undefined;
    date?: Date | undefined;
    ozonWarehouse?: OzonWarehouse | undefined;
}

export class FindOzonSupplyOrdersModel implements IFindOzonSupplyOrdersModel {
    offset!: number;
    count!: number;

    constructor(data?: IFindOzonSupplyOrdersModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.offset = _data["Offset"];
            this.count = _data["Count"];
        }
    }

    static fromJS(data: any): FindOzonSupplyOrdersModel {
        data = typeof data === 'object' ? data : {};
        let result = new FindOzonSupplyOrdersModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Offset"] = this.offset;
        data["Count"] = this.count;
        return data;
    }
}

export interface IFindOzonSupplyOrdersModel {
    offset: number;
    count: number;
}

export class PagedResponseOfOzonProducts implements IPagedResponseOfOzonProducts {
    totalCount!: number;
    items?: OzonProduct[] | undefined;

    constructor(data?: IPagedResponseOfOzonProducts) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["TotalCount"];
            if (Array.isArray(_data["Items"])) {
                this.items = [] as any;
                for (let item of _data["Items"])
                    this.items!.push(OzonProduct.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResponseOfOzonProducts {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfOzonProducts();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TotalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["Items"] = [];
            for (let item of this.items)
                data["Items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResponseOfOzonProducts {
    totalCount: number;
    items?: OzonProduct[] | undefined;
}

export class FindOzonProductsModel implements IFindOzonProductsModel {
    offset!: number;
    count!: number;
    productName?: string | undefined;
    productPackageID?: number | undefined;

    constructor(data?: IFindOzonProductsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.offset = _data["Offset"];
            this.count = _data["Count"];
            this.productName = _data["ProductName"];
            this.productPackageID = _data["ProductPackageID"];
        }
    }

    static fromJS(data: any): FindOzonProductsModel {
        data = typeof data === 'object' ? data : {};
        let result = new FindOzonProductsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Offset"] = this.offset;
        data["Count"] = this.count;
        data["ProductName"] = this.productName;
        data["ProductPackageID"] = this.productPackageID;
        return data;
    }
}

export interface IFindOzonProductsModel {
    offset: number;
    count: number;
    productName?: string | undefined;
    productPackageID?: number | undefined;
}

export class PagedResponseOfOzonOperations implements IPagedResponseOfOzonOperations {
    totalCount!: number;
    items?: OzonOperation[] | undefined;

    constructor(data?: IPagedResponseOfOzonOperations) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["TotalCount"];
            if (Array.isArray(_data["Items"])) {
                this.items = [] as any;
                for (let item of _data["Items"])
                    this.items!.push(OzonOperation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResponseOfOzonOperations {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfOzonOperations();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TotalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["Items"] = [];
            for (let item of this.items)
                data["Items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResponseOfOzonOperations {
    totalCount: number;
    items?: OzonOperation[] | undefined;
}

export class FindOzonOperationsModel implements IFindOzonOperationsModel {
    offset!: number;
    count!: number;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;

    constructor(data?: IFindOzonOperationsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.offset = _data["Offset"];
            this.count = _data["Count"];
            this.dateFrom = _data["DateFrom"] ? new Date(_data["DateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["DateTo"] ? new Date(_data["DateTo"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FindOzonOperationsModel {
        data = typeof data === 'object' ? data : {};
        let result = new FindOzonOperationsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Offset"] = this.offset;
        data["Count"] = this.count;
        data["DateFrom"] = this.dateFrom ? formatDate(this.dateFrom) : <any>undefined;
        data["DateTo"] = this.dateTo ? formatDate(this.dateTo) : <any>undefined;
        return data;
    }
}

export interface IFindOzonOperationsModel {
    offset: number;
    count: number;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
}

export class PackageTypeWithPrice implements IPackageTypeWithPrice {
    iD!: number;
    name?: string | undefined;
    unitOfMeasure!: UnitOfMeasure;
    decimalPlaces!: number;
    price?: number | undefined;

    constructor(data?: IPackageTypeWithPrice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iD = _data["ID"];
            this.name = _data["Name"];
            this.unitOfMeasure = _data["UnitOfMeasure"];
            this.decimalPlaces = _data["DecimalPlaces"];
            this.price = _data["Price"];
        }
    }

    static fromJS(data: any): PackageTypeWithPrice {
        data = typeof data === 'object' ? data : {};
        let result = new PackageTypeWithPrice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD;
        data["Name"] = this.name;
        data["UnitOfMeasure"] = this.unitOfMeasure;
        data["DecimalPlaces"] = this.decimalPlaces;
        data["Price"] = this.price;
        return data;
    }
}

export interface IPackageTypeWithPrice {
    iD: number;
    name?: string | undefined;
    unitOfMeasure: UnitOfMeasure;
    decimalPlaces: number;
    price?: number | undefined;
}

export enum UnitOfMeasure {
    Unknown = 0,
    SquareMeter = 1,
    Piece = 2,
}

export class PagedResponseOfProduct implements IPagedResponseOfProduct {
    totalCount!: number;
    items?: Product[] | undefined;

    constructor(data?: IPagedResponseOfProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["TotalCount"];
            if (Array.isArray(_data["Items"])) {
                this.items = [] as any;
                for (let item of _data["Items"])
                    this.items!.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResponseOfProduct {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfProduct();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TotalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["Items"] = [];
            for (let item of this.items)
                data["Items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResponseOfProduct {
    totalCount: number;
    items?: Product[] | undefined;
}

export class Product implements IProduct {
    iD!: number;
    categoryID!: number;
    name!: string;
    category?: ProductCategory | undefined;
    packages?: ProductPackage[] | undefined;

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iD = _data["ID"];
            this.categoryID = _data["CategoryID"];
            this.name = _data["Name"];
            this.category = _data["Category"] ? ProductCategory.fromJS(_data["Category"]) : <any>undefined;
            if (Array.isArray(_data["Packages"])) {
                this.packages = [] as any;
                for (let item of _data["Packages"])
                    this.packages!.push(ProductPackage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD;
        data["CategoryID"] = this.categoryID;
        data["Name"] = this.name;
        data["Category"] = this.category ? this.category.toJSON() : <any>undefined;
        if (Array.isArray(this.packages)) {
            data["Packages"] = [];
            for (let item of this.packages)
                data["Packages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProduct {
    iD: number;
    categoryID: number;
    name: string;
    category?: ProductCategory | undefined;
    packages?: ProductPackage[] | undefined;
}

export class ProductCategory implements IProductCategory {
    iD!: number;
    name!: string;
    product?: Product[] | undefined;

    constructor(data?: IProductCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iD = _data["ID"];
            this.name = _data["Name"];
            if (Array.isArray(_data["Product"])) {
                this.product = [] as any;
                for (let item of _data["Product"])
                    this.product!.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductCategory {
        data = typeof data === 'object' ? data : {};
        let result = new ProductCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD;
        data["Name"] = this.name;
        if (Array.isArray(this.product)) {
            data["Product"] = [];
            for (let item of this.product)
                data["Product"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductCategory {
    iD: number;
    name: string;
    product?: Product[] | undefined;
}

export class ProductPackage implements IProductPackage {
    iD!: number;
    name?: string | undefined;
    productCount!: number;
    productID!: number;
    product?: Product | undefined;

    constructor(data?: IProductPackage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iD = _data["ID"];
            this.name = _data["Name"];
            this.productCount = _data["ProductCount"];
            this.productID = _data["ProductID"];
            this.product = _data["Product"] ? Product.fromJS(_data["Product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ProductPackage {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPackage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD;
        data["Name"] = this.name;
        data["ProductCount"] = this.productCount;
        data["ProductID"] = this.productID;
        data["Product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data;
    }
}

export interface IProductPackage {
    iD: number;
    name?: string | undefined;
    productCount: number;
    productID: number;
    product?: Product | undefined;
}

export class FindProductsModel implements IFindProductsModel {
    offset!: number;
    count!: number;
    productName?: string | undefined;

    constructor(data?: IFindProductsModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.offset = _data["Offset"];
            this.count = _data["Count"];
            this.productName = _data["ProductName"];
        }
    }

    static fromJS(data: any): FindProductsModel {
        data = typeof data === 'object' ? data : {};
        let result = new FindProductsModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Offset"] = this.offset;
        data["Count"] = this.count;
        data["ProductName"] = this.productName;
        return data;
    }
}

export interface IFindProductsModel {
    offset: number;
    count: number;
    productName?: string | undefined;
}

export class PagedResponseOfProductPackage implements IPagedResponseOfProductPackage {
    totalCount!: number;
    items?: ProductPackage[] | undefined;

    constructor(data?: IPagedResponseOfProductPackage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["TotalCount"];
            if (Array.isArray(_data["Items"])) {
                this.items = [] as any;
                for (let item of _data["Items"])
                    this.items!.push(ProductPackage.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResponseOfProductPackage {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfProductPackage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TotalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["Items"] = [];
            for (let item of this.items)
                data["Items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResponseOfProductPackage {
    totalCount: number;
    items?: ProductPackage[] | undefined;
}

export class FindProductPackagesModel implements IFindProductPackagesModel {
    offset!: number;
    count!: number;
    productPackageName?: string | undefined;
    productID?: number | undefined;

    constructor(data?: IFindProductPackagesModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.offset = _data["Offset"];
            this.count = _data["Count"];
            this.productPackageName = _data["ProductPackageName"];
            this.productID = _data["ProductID"];
        }
    }

    static fromJS(data: any): FindProductPackagesModel {
        data = typeof data === 'object' ? data : {};
        let result = new FindProductPackagesModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Offset"] = this.offset;
        data["Count"] = this.count;
        data["ProductPackageName"] = this.productPackageName;
        data["ProductID"] = this.productID;
        return data;
    }
}

export interface IFindProductPackagesModel {
    offset: number;
    count: number;
    productPackageName?: string | undefined;
    productID?: number | undefined;
}

export class PurchaseBatch implements IPurchaseBatch {
    iD!: number;
    name?: string | undefined;
    date!: Date;
    status!: PurchaseBatchStatus;
    items?: PurchaseBatchItem[] | undefined;

    constructor(data?: IPurchaseBatch) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iD = _data["ID"];
            this.name = _data["Name"];
            this.date = _data["Date"] ? new Date(_data["Date"].toString()) : <any>undefined;
            this.status = _data["Status"];
            if (Array.isArray(_data["Items"])) {
                this.items = [] as any;
                for (let item of _data["Items"])
                    this.items!.push(PurchaseBatchItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PurchaseBatch {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseBatch();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD;
        data["Name"] = this.name;
        data["Date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["Status"] = this.status;
        if (Array.isArray(this.items)) {
            data["Items"] = [];
            for (let item of this.items)
                data["Items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPurchaseBatch {
    iD: number;
    name?: string | undefined;
    date: Date;
    status: PurchaseBatchStatus;
    items?: PurchaseBatchItem[] | undefined;
}

export enum PurchaseBatchStatus {
    Unknown = 0,
    Purchased = 1,
    InSale = 2,
    Sold = 3,
}

export class PurchaseBatchItem implements IPurchaseBatchItem {
    iD!: number;
    count!: number;
    price!: number;
    productID!: number;
    purchaseBatchID!: number;
    product?: Product | undefined;
    purchaseBatch?: PurchaseBatch | undefined;
    salesItems?: SalesItem[] | undefined;

    constructor(data?: IPurchaseBatchItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iD = _data["ID"];
            this.count = _data["Count"];
            this.price = _data["Price"];
            this.productID = _data["ProductID"];
            this.purchaseBatchID = _data["PurchaseBatchID"];
            this.product = _data["Product"] ? Product.fromJS(_data["Product"]) : <any>undefined;
            this.purchaseBatch = _data["PurchaseBatch"] ? PurchaseBatch.fromJS(_data["PurchaseBatch"]) : <any>undefined;
            if (Array.isArray(_data["SalesItems"])) {
                this.salesItems = [] as any;
                for (let item of _data["SalesItems"])
                    this.salesItems!.push(SalesItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PurchaseBatchItem {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseBatchItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD;
        data["Count"] = this.count;
        data["Price"] = this.price;
        data["ProductID"] = this.productID;
        data["PurchaseBatchID"] = this.purchaseBatchID;
        data["Product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["PurchaseBatch"] = this.purchaseBatch ? this.purchaseBatch.toJSON() : <any>undefined;
        if (Array.isArray(this.salesItems)) {
            data["SalesItems"] = [];
            for (let item of this.salesItems)
                data["SalesItems"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPurchaseBatchItem {
    iD: number;
    count: number;
    price: number;
    productID: number;
    purchaseBatchID: number;
    product?: Product | undefined;
    purchaseBatch?: PurchaseBatch | undefined;
    salesItems?: SalesItem[] | undefined;
}

export class SalesItem implements ISalesItem {
    iD!: number;
    name!: string;
    volume!: number;
    packagingPrice!: number;
    purchaseBatchItemID!: number;
    productPackageID!: number;
    productPackage?: ProductPackage | undefined;
    purchaseBatchItem?: PurchaseBatchItem | undefined;
    salesItemPackages?: SalesItemPackage[] | undefined;
    salesPlans?: SalesPlan[] | undefined;

    constructor(data?: ISalesItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iD = _data["ID"];
            this.name = _data["Name"];
            this.volume = _data["Volume"];
            this.packagingPrice = _data["PackagingPrice"];
            this.purchaseBatchItemID = _data["PurchaseBatchItemID"];
            this.productPackageID = _data["ProductPackageID"];
            this.productPackage = _data["ProductPackage"] ? ProductPackage.fromJS(_data["ProductPackage"]) : <any>undefined;
            this.purchaseBatchItem = _data["PurchaseBatchItem"] ? PurchaseBatchItem.fromJS(_data["PurchaseBatchItem"]) : <any>undefined;
            if (Array.isArray(_data["SalesItemPackages"])) {
                this.salesItemPackages = [] as any;
                for (let item of _data["SalesItemPackages"])
                    this.salesItemPackages!.push(SalesItemPackage.fromJS(item));
            }
            if (Array.isArray(_data["SalesPlans"])) {
                this.salesPlans = [] as any;
                for (let item of _data["SalesPlans"])
                    this.salesPlans!.push(SalesPlan.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SalesItem {
        data = typeof data === 'object' ? data : {};
        let result = new SalesItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD;
        data["Name"] = this.name;
        data["Volume"] = this.volume;
        data["PackagingPrice"] = this.packagingPrice;
        data["PurchaseBatchItemID"] = this.purchaseBatchItemID;
        data["ProductPackageID"] = this.productPackageID;
        data["ProductPackage"] = this.productPackage ? this.productPackage.toJSON() : <any>undefined;
        data["PurchaseBatchItem"] = this.purchaseBatchItem ? this.purchaseBatchItem.toJSON() : <any>undefined;
        if (Array.isArray(this.salesItemPackages)) {
            data["SalesItemPackages"] = [];
            for (let item of this.salesItemPackages)
                data["SalesItemPackages"].push(item.toJSON());
        }
        if (Array.isArray(this.salesPlans)) {
            data["SalesPlans"] = [];
            for (let item of this.salesPlans)
                data["SalesPlans"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISalesItem {
    iD: number;
    name: string;
    volume: number;
    packagingPrice: number;
    purchaseBatchItemID: number;
    productPackageID: number;
    productPackage?: ProductPackage | undefined;
    purchaseBatchItem?: PurchaseBatchItem | undefined;
    salesItemPackages?: SalesItemPackage[] | undefined;
    salesPlans?: SalesPlan[] | undefined;
}

export class SalesItemPackage implements ISalesItemPackage {
    amount!: number;
    pricePerUom!: number;
    packageTypeID!: number;
    salesItemID!: number;
    salesItem?: SalesItem | undefined;
    packageType?: PackageType | undefined;

    constructor(data?: ISalesItemPackage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["Amount"];
            this.pricePerUom = _data["PricePerUom"];
            this.packageTypeID = _data["PackageTypeID"];
            this.salesItemID = _data["SalesItemID"];
            this.salesItem = _data["SalesItem"] ? SalesItem.fromJS(_data["SalesItem"]) : <any>undefined;
            this.packageType = _data["PackageType"] ? PackageType.fromJS(_data["PackageType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SalesItemPackage {
        data = typeof data === 'object' ? data : {};
        let result = new SalesItemPackage();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Amount"] = this.amount;
        data["PricePerUom"] = this.pricePerUom;
        data["PackageTypeID"] = this.packageTypeID;
        data["SalesItemID"] = this.salesItemID;
        data["SalesItem"] = this.salesItem ? this.salesItem.toJSON() : <any>undefined;
        data["PackageType"] = this.packageType ? this.packageType.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISalesItemPackage {
    amount: number;
    pricePerUom: number;
    packageTypeID: number;
    salesItemID: number;
    salesItem?: SalesItem | undefined;
    packageType?: PackageType | undefined;
}

export class PackageType implements IPackageType {
    iD!: number;
    name?: string | undefined;
    unitOfMeasure!: UnitOfMeasure;
    decimalPlaces!: number;
    prices?: PackageTypePrice[] | undefined;

    constructor(data?: IPackageType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iD = _data["ID"];
            this.name = _data["Name"];
            this.unitOfMeasure = _data["UnitOfMeasure"];
            this.decimalPlaces = _data["DecimalPlaces"];
            if (Array.isArray(_data["Prices"])) {
                this.prices = [] as any;
                for (let item of _data["Prices"])
                    this.prices!.push(PackageTypePrice.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PackageType {
        data = typeof data === 'object' ? data : {};
        let result = new PackageType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD;
        data["Name"] = this.name;
        data["UnitOfMeasure"] = this.unitOfMeasure;
        data["DecimalPlaces"] = this.decimalPlaces;
        if (Array.isArray(this.prices)) {
            data["Prices"] = [];
            for (let item of this.prices)
                data["Prices"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPackageType {
    iD: number;
    name?: string | undefined;
    unitOfMeasure: UnitOfMeasure;
    decimalPlaces: number;
    prices?: PackageTypePrice[] | undefined;
}

export class PackageTypePrice implements IPackageTypePrice {
    packageTypeID!: number;
    price!: number;
    date!: Date;

    constructor(data?: IPackageTypePrice) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.packageTypeID = _data["PackageTypeID"];
            this.price = _data["Price"];
            this.date = _data["Date"] ? new Date(_data["Date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): PackageTypePrice {
        data = typeof data === 'object' ? data : {};
        let result = new PackageTypePrice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["PackageTypeID"] = this.packageTypeID;
        data["Price"] = this.price;
        data["Date"] = this.date ? this.date.toISOString() : <any>undefined;
        return data;
    }
}

export interface IPackageTypePrice {
    packageTypeID: number;
    price: number;
    date: Date;
}

export class SalesPlan implements ISalesPlan {
    iD!: number;
    status!: SalesPlanStatus;
    price!: number;
    amount!: number;
    salesPerMonth!: number;
    commissionMultiplier!: number;
    commissionAddition!: number;
    returnPercentage!: number;
    returnCost!: number;
    deliveryCost!: number;
    deliveryDate!: Date;
    marketingBudget!: number;
    salesItemID!: number;
    salesChannelID!: number;
    salesItem?: SalesItem | undefined;
    salesChannel?: SalesChannel | undefined;

    constructor(data?: ISalesPlan) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iD = _data["ID"];
            this.status = _data["Status"];
            this.price = _data["Price"];
            this.amount = _data["Amount"];
            this.salesPerMonth = _data["SalesPerMonth"];
            this.commissionMultiplier = _data["CommissionMultiplier"];
            this.commissionAddition = _data["CommissionAddition"];
            this.returnPercentage = _data["ReturnPercentage"];
            this.returnCost = _data["ReturnCost"];
            this.deliveryCost = _data["DeliveryCost"];
            this.deliveryDate = _data["DeliveryDate"] ? new Date(_data["DeliveryDate"].toString()) : <any>undefined;
            this.marketingBudget = _data["MarketingBudget"];
            this.salesItemID = _data["SalesItemID"];
            this.salesChannelID = _data["SalesChannelID"];
            this.salesItem = _data["SalesItem"] ? SalesItem.fromJS(_data["SalesItem"]) : <any>undefined;
            this.salesChannel = _data["SalesChannel"] ? SalesChannel.fromJS(_data["SalesChannel"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SalesPlan {
        data = typeof data === 'object' ? data : {};
        let result = new SalesPlan();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD;
        data["Status"] = this.status;
        data["Price"] = this.price;
        data["Amount"] = this.amount;
        data["SalesPerMonth"] = this.salesPerMonth;
        data["CommissionMultiplier"] = this.commissionMultiplier;
        data["CommissionAddition"] = this.commissionAddition;
        data["ReturnPercentage"] = this.returnPercentage;
        data["ReturnCost"] = this.returnCost;
        data["DeliveryCost"] = this.deliveryCost;
        data["DeliveryDate"] = this.deliveryDate ? formatDate(this.deliveryDate) : <any>undefined;
        data["MarketingBudget"] = this.marketingBudget;
        data["SalesItemID"] = this.salesItemID;
        data["SalesChannelID"] = this.salesChannelID;
        data["SalesItem"] = this.salesItem ? this.salesItem.toJSON() : <any>undefined;
        data["SalesChannel"] = this.salesChannel ? this.salesChannel.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISalesPlan {
    iD: number;
    status: SalesPlanStatus;
    price: number;
    amount: number;
    salesPerMonth: number;
    commissionMultiplier: number;
    commissionAddition: number;
    returnPercentage: number;
    returnCost: number;
    deliveryCost: number;
    deliveryDate: Date;
    marketingBudget: number;
    salesItemID: number;
    salesChannelID: number;
    salesItem?: SalesItem | undefined;
    salesChannel?: SalesChannel | undefined;
}

export enum SalesPlanStatus {
    Draft = 0,
    InProcess = 1,
    Finalized = 2,
}

export class SalesChannel implements ISalesChannel {
    iD!: number;
    name?: string | undefined;

    constructor(data?: ISalesChannel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iD = _data["ID"];
            this.name = _data["Name"];
        }
    }

    static fromJS(data: any): SalesChannel {
        data = typeof data === 'object' ? data : {};
        let result = new SalesChannel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD;
        data["Name"] = this.name;
        return data;
    }
}

export interface ISalesChannel {
    iD: number;
    name?: string | undefined;
}

export class PagedResponseOfPurchaseBatches implements IPagedResponseOfPurchaseBatches {
    totalCount!: number;
    items?: PurchaseBatch[] | undefined;

    constructor(data?: IPagedResponseOfPurchaseBatches) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["TotalCount"];
            if (Array.isArray(_data["Items"])) {
                this.items = [] as any;
                for (let item of _data["Items"])
                    this.items!.push(PurchaseBatch.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResponseOfPurchaseBatches {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResponseOfPurchaseBatches();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["TotalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["Items"] = [];
            for (let item of this.items)
                data["Items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResponseOfPurchaseBatches {
    totalCount: number;
    items?: PurchaseBatch[] | undefined;
}

export class FindPurchaseBatchesModel implements IFindPurchaseBatchesModel {
    offset!: number;
    count!: number;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;

    constructor(data?: IFindPurchaseBatchesModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.offset = _data["Offset"];
            this.count = _data["Count"];
            this.dateFrom = _data["DateFrom"] ? new Date(_data["DateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["DateTo"] ? new Date(_data["DateTo"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FindPurchaseBatchesModel {
        data = typeof data === 'object' ? data : {};
        let result = new FindPurchaseBatchesModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Offset"] = this.offset;
        data["Count"] = this.count;
        data["DateFrom"] = this.dateFrom ? formatDate(this.dateFrom) : <any>undefined;
        data["DateTo"] = this.dateTo ? formatDate(this.dateTo) : <any>undefined;
        return data;
    }
}

export interface IFindPurchaseBatchesModel {
    offset: number;
    count: number;
    dateFrom?: Date | undefined;
    dateTo?: Date | undefined;
}

export class SalesPlanSummary implements ISalesPlanSummary {
    iD!: number;
    salesCount!: number;
    returnCount!: number;
    commissionPercent!: number;
    commissionAddition!: number;
    returnSum!: number;
    salesSum!: number;

    constructor(data?: ISalesPlanSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.iD = _data["ID"];
            this.salesCount = _data["SalesCount"];
            this.returnCount = _data["ReturnCount"];
            this.commissionPercent = _data["CommissionPercent"];
            this.commissionAddition = _data["CommissionAddition"];
            this.returnSum = _data["ReturnSum"];
            this.salesSum = _data["SalesSum"];
        }
    }

    static fromJS(data: any): SalesPlanSummary {
        data = typeof data === 'object' ? data : {};
        let result = new SalesPlanSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ID"] = this.iD;
        data["SalesCount"] = this.salesCount;
        data["ReturnCount"] = this.returnCount;
        data["CommissionPercent"] = this.commissionPercent;
        data["CommissionAddition"] = this.commissionAddition;
        data["ReturnSum"] = this.returnSum;
        data["SalesSum"] = this.salesSum;
        return data;
    }
}

export interface ISalesPlanSummary {
    iD: number;
    salesCount: number;
    returnCount: number;
    commissionPercent: number;
    commissionAddition: number;
    returnSum: number;
    salesSum: number;
}

export class JwtToken implements IJwtToken {
    accessToken?: string | undefined;
    refreshToken?: string | undefined;

    constructor(data?: IJwtToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["AccessToken"];
            this.refreshToken = _data["RefreshToken"];
        }
    }

    static fromJS(data: any): JwtToken {
        data = typeof data === 'object' ? data : {};
        let result = new JwtToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["AccessToken"] = this.accessToken;
        data["RefreshToken"] = this.refreshToken;
        return data;
    }
}

export interface IJwtToken {
    accessToken?: string | undefined;
    refreshToken?: string | undefined;
}

export class LoginModel implements ILoginModel {
    login?: string | undefined;
    password?: string | undefined;

    constructor(data?: ILoginModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.login = _data["Login"];
            this.password = _data["Password"];
        }
    }

    static fromJS(data: any): LoginModel {
        data = typeof data === 'object' ? data : {};
        let result = new LoginModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Login"] = this.login;
        data["Password"] = this.password;
        return data;
    }
}

export interface ILoginModel {
    login?: string | undefined;
    password?: string | undefined;
}

function formatDate(d: Date) {
    return d.getFullYear() + '-' + 
        (d.getMonth() < 9 ? ('0' + (d.getMonth()+1)) : (d.getMonth()+1)) + '-' +
        (d.getDate() < 10 ? ('0' + d.getDate()) : d.getDate());
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}

}